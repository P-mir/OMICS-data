PCA.res = prcomp(irismat, center = T, scale = T)
pander(summary(PCA.res))
plot(PCA.res,type="l",main="Scree plot")
fviz_screeplot(PCA.res, ncp=ncomp, choice="eigenvalue")
fviz_pca_var(PCA.res)
fviz_pca_ind(PCA.res,cex=0.2,addEllipses=T, habillage=Classes)
fviz_pca_biplot(PCA.res,habillage=Classes)
ncomp=4
PCA.res = SVDforPCA(irismatS,ncomp = ncomp)
# Installation des librairies si ce n'est pas encore fait
knitr::opts_chunk$set(echo = TRUE)
require(devtools)
install_github("ManonMartin/MBXUCL", force = TRUE,dependencies=T)
install_github("kassambara/factoextra")
# install.packages("cluster")
# Chargement des librairies
require(MBXUCL) # Librairie MBX de l'ISBA-SMCS
require(knitr)
require(pander) # Librairie pour afficher des tableaux
require(factoextra) # librairie pour faire des beaux graphiques en stat multivariée
require(cluster) # librairie de clustering
require(FactoMineR)
ncomp=4
PCA.res = SVDforPCA(irismatS,ncomp = ncomp)
ncomp=4
PCA.res = SVDforPCA(irismatS,ncomp = ncomp)
fviz_pca_ind(PCA.res,cex=0.2,addEllipses=T, habillage=Classes)
ncomp=4
PCA.res = prcomp(irismat, center = T, scale = T)
pander(summary(PCA.res))
fviz_pca_var(PCA.res)
biplot(PCA.res,cex=0.5)
fviz_pca_biplot(PCA.res,habillage=Classes)
fviz_pca_ind(PCA.res,cex=0.2,addEllipses=T, habillage=Classes)
fviz_pca_biplot(PCA.res,habillage=Classes)
fviz_pca_ind(PCA.res,cex=0.2,addEllipses=T, habillage=Classes)
PCA.res = prcomp(df, center = T, scale = T)
require(factoextra)
df
res.pca = PCA(irismat, scale.unit=TRUE, ncp=5)
plot.PCA(res.pca, axes=c(1, 2), choix="ind", col.ind=Classes,cex=0.5)
plot.PCA(res.pca, axes=c(1, 2), choix="var")
irismat
class(irismat)
as.matrix(df)
PCA.res = prcomp(as.matrix(df), center = T, scale = T)
ncomp=4
PCA.res = prcomp(as.matrix(df), center = T, scale = T)
df$Groupe= as.factor(df$Groupe)
df
df[-2]
PCA.res = prcomp(as.matrix(df[-2]), center = T, scale = T)
df$Groupe= as.factor(df$Groupe)
ncomp=4
PCA.res = prcomp(as.matrix(df[-2]), center = T, scale = T)
irismat
ncomp=4
PCA.res = prcomp(irismat, center = T, scale = T)
pander(summary(PCA.res))
plot(PCA.res,type="l",main="Scree plot")
fviz_pca_var(PCA.res)
fviz_pca_ind(PCA.res,cex=0.2,addEllipses=T, habillage=Classes)
df[-c(1,2])
df[-c(1,2])]
df[-c(1,2)]
PCA.res = prcomp(as.matrix(df[-c(1,2)]), center = T, scale = T)
PCA.res = prcomp(df[-c(1,2)], center = T, scale = T)
pander(summary(PCA.res))
PCA.res
pander(summary(PCA.res[,2]))
PCA.res[,2]
PCA.res[2]
library(FactoMineR)
pander(summary(PCA.res[2],np=ncomp,nb.dec=2))
pander(summary(PCA.res,np=ncomp,nb.dec=2))
pander(summary.PCA(PCA.res,np=ncomp,nb.dec=2))
class(PCA.res)
pander(summary.pca(PCA.res,np=ncomp,nb.dec=2))
pander(summary.PCA(PCA.res,np=ncomp,nb.dec=2))
summary.PCA(PCA.res,np=ncomp,nb.dec=2)
PCA.res = PCA(df[-c(1,2)], scale.unit=TRUE, ncp=ncp)
ncp=4
PCA.res = PCA(df[-c(1,2)], scale.unit=TRUE, ncp=ncp)
pander(summary.PCA(PCA.res,nb.dec=2))
pander(summary.PCA(PCA.res,ncp=ncp,nb.dec=2))
PCA.res = prcomp(df[-c(1,2)],center = T, scale = T,rank. = ncp)
pander(summary(PCA.res,))
pander(summary(PCA.res))
PCA.res = prcomp(irismat, center = T, scale = T)
pander(summary(PCA.res))
PCA.res = prcomp(df[-c(1,2)],center = T, scale = T,rank. = ncp)
pander(summary(PCA.res))
pander(summary.PCA(PCA.res,ncp=,ncp))
PCA.res
pander(summary.PCA(PCA.res))
pander(summary(PCA.res))
PCA.res$rotation
pander(PCA.res$rotation)
pander(PCA.res$sdev)
pander(PCA.res$rotation)
pander(PCA.res$x)
kable(PCA.res$x)
pander(round(PCA.res$rotation),2)
kable(round(PCA.res$x),2)
pander(round(PCA.res$x),2)
kable(round(PCA.res$x,2))
pander(round(PCA.res$rotation,2))
shap=apply(data[3:40],2,shapiro.test)
pvalues = sapply(shap, `[`, c("p.value"))
pvalues
shap=apply(data[3:40],2,shapiro.test)
pvalues = sapply(shap, `[`, c("p.value"))
pvalues = pvalues[ which(pvalues<0.05)]
pander(pvalues)
shap=apply(data[3:40],2,shapiro.test)
pvalues = sapply(shap, `[`, c("p.value"))
pvalues = pvalues[ which(pvalues<0.05)]
pander(pvalues)
shap=apply(data[3:40],2,shapiro.test)
pvalues = sapply(shap, `[`, c("p.value"))
pvalues = pvalues[ which(pvalues<0.05)]
pander(pvalues)
setwd("C:/Users/p/OneDrive - UCL/Traitement des données omics/data")
setwd("C:/Users/p/OneDrive - UCL/Traitement des données omics/data")
knitr::opts_chunk$set(echo = TRUE)
#install.packages(multtest)
qPCR_data = read.csv("C:/Users/p/OneDrive - UCL/Traitement des données omics/data/data_qPCR.csv", sep = ";", dec = "." , header = TRUE)
rownames(qPCR_data) = qPCR_data[,2]
# données log-transformées et "brutes"
n=dim(qPCR_data)[1]
RAWdata = as.matrix(qPCR_data[,c(3:21)])
RAWdataNC=RAWdata
LOGdata = as.matrix(qPCR_data[,c(22:40)])
m=19
# Centrage et standardisation des données
RAWdata=RAWdata-matrix(apply(RAWdata,2,mean),nrow=n,ncol=m,byrow=T)
RAWdata=RAWdata/matrix(sqrt(apply(RAWdata,2,var)),nrow=n,ncol=m,byrow=T)
LOGdata=LOGdata-matrix(apply(LOGdata,2,mean),nrow=n,ncol=m,byrow=T)
LOGdata=LOGdata/matrix(sqrt(apply(LOGdata,2,var)),nrow=n,ncol=m,byrow=T)
qPCR_data = read.csv("C:/Users/p/OneDrive - UCL/Traitement des données omics/data/data_qPCR.csv", sep = ";", dec = "." , header = TRUE)
rownames(qPCR_data) = qPCR_data[,2]
# données log-transformées et "brutes"
n=dim(qPCR_data)[1]
RAWdata = as.matrix(qPCR_data[,c(3:21)])
RAWdataNC=RAWdata
LOGdata = as.matrix(qPCR_data[,c(22:40)])
m=19
# Centrage et standardisation des données
RAWdata=RAWdata-matrix(apply(RAWdata,2,mean),nrow=n,ncol=m,byrow=T)
RAWdata=RAWdata/matrix(sqrt(apply(RAWdata,2,var)),nrow=n,ncol=m,byrow=T)
LOGdata=LOGdata-matrix(apply(LOGdata,2,mean),nrow=n,ncol=m,byrow=T)
LOGdata=LOGdata/matrix(sqrt(apply(LOGdata,2,var)),nrow=n,ncol=m,byrow=T)
# classe des miRs
Class = rep(0, dim(qPCR_data)[1])
Class[qPCR_data[,1]=="malade"] = 1
table(Class)
data = list(RAWdata = RAWdata, LOGdata =LOGdata)
table(qPCR_data[,1])
p_value <- numeric(length=m)
for(i in 1:m) {
p_value[i] <- t.test(RAWdata[Class==1,i], RAWdata[Class==0,i], var.equal = FALSE)$p.value
}
hist(p_value)
cat("Nombre de tests significatifs:",sum(p_value<0.05)," sur ",m," càd ",100*round(sum(p_value<0.05)/m,2),"%.")
p_val_sort=sort(p_value)
q_value=numeric(length=m)
for (i in 1:m){
q_value[i]=(m*p_val_sort[i])/i
}
plot(1:m,q_value)
first_not_signif=which((q_value<0.05)=="FALSE")[1]
cat("Nombre de tests significatifs après correction FDR:",first_not_signif-1," sur ",m," càd ",100*round((first_not_signif-1)/m,2),"%.")
# par la fonction p.adjust:
sort(p.adjust(p_value,method = "hochberg"))
require(multtest)
install.packages(multtest)
install.packages(multtest)
require(multtest)
num=matrix(nrow=9,ncol=1)
rownames(num)=c("Bonferroni","Holm","Hochberg","SidakSS","SidakSD","BH","BY","ABH","TSBH")
cat("Bonferroni","\n")
res<-mt.rawp2adjp(p_value, proc=c("Bonferroni"))
num[1,1]=sum(res$adjp[,2]<0.05)
cat("Holm","\n")
# Holm (1979) step-down adjusted p-values for strong control of the FWER.
mt.rawp2adjp(p_value, proc=c("Holm"))
num[2,1]=sum(res$adjp[,2]<0.05)
cat("Hochberg","\n")
#Hochberg (1988) step-up adjusted p-values for strong control of the FWER (for raw (unadjusted) p-values satisfying the Simes inequality).
mt.rawp2adjp(p_value, proc=c("Hochberg"))
num[3,1]=sum(res$adjp[,2]<0.05)
cat("SidakSS","\n")
#Sidak single-step adjusted p-values for strong control of the FWER (for positive orthant dependent test statistics).
mt.rawp2adjp(p_value, proc=c("SidakSS"))
num[4,1]=sum(res$adjp[,2]<0.05)
cat("SidakSD","\n")
#Sidak step-down adjusted p-values for strong control of the FWER (for positive orthant dependent test statistics).
mt.rawp2adjp(p_value, proc=c("SidakSD"))
num[5,1]=sum(res$adjp[,2]<0.05)
cat("BH","\n")
#Adjusted p-values for the Benjamini & Hochberg (1995) step-up FDR-controlling procedure (independent and positive regression dependent test statistics).
mt.rawp2adjp(p_value, proc=c("BH"))
num[6,1]=sum(res$adjp[,2]<0.05)
cat("BY","\n")
#Adjusted p-values for the Benjamini & Yekutieli (2001) step-up FDR-controlling procedure (general dependency structures).
mt.rawp2adjp(p_value, proc=c("BY"))
num[7,1]=sum(res$adjp[,2]<0.05)
cat("ABH","\n")
#Adjusted p-values for the adaptive Benjamini & Hochberg (2000) step-up FDR-controlling procedure. This method ammends the original step-up procedure using an estimate of the number of true null hypotheses obtained from p-values.
mt.rawp2adjp(p_value, proc=c("ABH"))
num[8,1]=sum(res$adjp[,2]<0.05)
cat("TSBH","\n")
#Adjusted p-values for the two-stage Benjamini & Hochberg (2006) step-up FDR-controlling procedure. This method ammends the original step-up procedure using an estimate of the number of true null hypotheses obtained from a first-pass application of "BH". The adjusted p-values are a-dependent, therefore alpha must be set in the function arguments when using this procedure.
mt.rawp2adjp(p_value, proc=c("TSBH"))
num[9,1]=sum(res$adjp[,2]<0.05)
install.packages('multtest')
install.packages("multtest")
require(multtest)
PCA.res = prcomp(df[-c(1,2)],center = T, scale = T,rank. = ncp)
PCA.res
fviz_screeplot(PCA.res, ncp=ncomp, choice="eigenvalue")
fviz_screeplot(PCA.res, choice="eigenvalue")
fviz_pca_var(PCA.res)
fviz_pca_biplot(PCA.res,habillage=Classes)
Classes=df$Groupe
fviz_pca_biplot(PCA.res,habillage=Classes)
wilcox_pvalues[20]
wilcox_pvalues[15:25]
df[15:25]
df[15:22]
df[3:21]
boxplot(x=sick[3:21],main="Boxplot of the miRNA",xlab="miRNA",col = "blue",names=F)
boxplot(x=control[3:21],main="Boxplot of the miRNA",xlab="miRNA",col = "blue",names=F)
std=5
outliers = boxplot(sick[3:40], plot=FALSE,range=std)$out
outliers
for (i in 3:40) {
sick= sick[!sick[,i] %in% boxplot(sick[,i], plot=FALSE,range=std)$out,]
}
control= control[!control[,i] %in% boxplot(control[,i], plot=FALSE,range=std)$out,]
message("Proportion (%) of outliers: ", round((length(data[,1])-length(sick[,1])-length(sick[,1])) /length(data[,1])*100,2))
control
message("Proportion (%) of outliers: ", round((length(data[,1])-length(sick[,1])-length(control[,1])) /length(data[,1])*100,2))
data[,1]
data=read.table("data_qPCR.csv",header=T,sep=";",dec=".")
message("Proportion (%) of outliers: ", round((length(data[,1])-length(sick[,1])-length(control[,1])) /length(data[,1])*100,2))
length(data[,1])-length(sick[,1])-length(control[,1])
length(sick[,1])
length(control[,1])
boxplot(sick[3:40], plot=FALSE,range=std)$out
std=5
std=3
boxplot(sick[3:40], plot=FALSE,range=std)$out
std=3.5
boxplot(sick[3:40], plot=FALSE,range=std)$out
boxplot(control[3:40], plot=FALSE,range=std)$out
std=3.5
outliers = boxplot(sick[3:40], plot=FALSE,range=std)$out
for (i in 3:40) {
sick= sick[!sick[,i] %in% boxplot(sick[,i], plot=FALSE,range=std)$out,]
}
outliers = boxplot(control[3:40], plot=FALSE,range=std)$out
for (i in 3:40) {
control= control[!control[,i] %in% boxplot(control[,i], plot=FALSE,range=std)$out,]
}
message("Proportion (%) of outliers: ", round((length(data[,1])-length(sick[,1])-length(control[,1])) /length(data[,1])*100,2))
#how to choose the ones to remove?
# why removing the outliers?
std=4
outliers = boxplot(sick[3:40], plot=FALSE,range=std)$out
for (i in 3:40) {
sick= sick[!sick[,i] %in% boxplot(sick[,i], plot=FALSE,range=std)$out,]
}
outliers = boxplot(control[3:40], plot=FALSE,range=std)$out
for (i in 3:40) {
control= control[!control[,i] %in% boxplot(control[,i], plot=FALSE,range=std)$out,]
}
message("Proportion (%) of outliers: ", round((length(data[,1])-length(sick[,1])-length(control[,1])) /length(data[,1])*100,2))
length(data[,1])-length(sick[,1])-length(control[,1])
#how to choose the ones to remove?
# why removing the outliers?
std=5
outliers = boxplot(sick[3:40], plot=FALSE,range=std)$out
for (i in 3:40) {
sick= sick[!sick[,i] %in% boxplot(sick[,i], plot=FALSE,range=std)$out,]
}
outliers = boxplot(control[3:40], plot=FALSE,range=std)$out
for (i in 3:40) {
control= control[!control[,i] %in% boxplot(control[,i], plot=FALSE,range=std)$out,]
}
message("Proportion (%) of outliers: ", round((length(data[,1])-length(sick[,1])-length(control[,1])) /length(data[,1])*100,2))
#how to choose the ones to remove?
# why removing the outliers?
std=2
outliers = boxplot(sick[3:40], plot=FALSE,range=std)$out
for (i in 3:40) {
sick= sick[!sick[,i] %in% boxplot(sick[,i], plot=FALSE,range=std)$out,]
}
outliers = boxplot(control[3:40], plot=FALSE,range=std)$out
for (i in 3:40) {
control= control[!control[,i] %in% boxplot(control[,i], plot=FALSE,range=std)$out,]
}
message("Proportion (%) of outliers: ", round((length(data[,1])-length(sick[,1])-length(control[,1])) /length(data[,1])*100,2))
setwd("C:/Users/p/OneDrive - UCL/Traitement des données omics/Devoirs/projet données qPCR")
data=read.table("data_qPCR.csv",header=T,sep=";",dec=".")
sick=data[ which(data$Groupe=='malade'), ]
control=data[ which(data$Groupe=='temoin'), ]
smean=apply(sick[(3:40)],2,mean)
cmean=apply(control[(3:40)],2,mean)
barplot(height=t(cbind(smean,cmean)),beside=T,space=c(0,2),col=c("black","red"), border=F,main="Mean comparison")
legend("topleft",legend=c("sick","control"),fill=c("black","red"),cex=0.8)
smedian=apply(sick[(3:40)],2,median)
cmedian=apply(control[(3:40)],2,median)
barplot(height=t(cbind(smedian,cmedian)),beside=T,space=c(0,2),col=c("black","red"), border=F,main="Median comparison")
legend("topright",legend=c("sick","control"),fill=c("black","red"),cex=0.8)
#how to choose the ones to remove?
# why removing the outliers?
std=2
outliers = boxplot(sick[3:40], plot=FALSE,range=std)$out
for (i in 3:40) {
Sick= sick[!sick[,i] %in% boxplot(sick[,i], plot=FALSE,range=std)$out,]
}
outliers = boxplot(control[3:40], plot=FALSE,range=std)$out
for (i in 3:40) {
Control= control[!control[,i] %in% boxplot(control[,i], plot=FALSE,range=std)$out,]
}
message("Proportion (%) of outliers: ", round((length(data[,1])-length(Sick[,1])-length(Control[,1])) /length(data[,1])*100,2))
std=2
outliers = boxplot(sick[3:40], plot=FALSE,range=std)$out
boxplot(sick[3:40], plot=FALSE,range=std)$out
for (i in 3:40) {
Sick= sick[!sick[,i] %in% boxplot(sick[,i], plot=FALSE,range=std)$out,]
}
Sick=sick
#how to choose the ones to remove?
# why removing the outliers?
std=2
outliers = boxplot(sick[3:40], plot=FALSE,range=std)$out
Sick=sick
for (i in 3:40) {
Sick= sick[!sick[,i] %in% boxplot(sick[,i], plot=FALSE,range=std)$out,]
}
outliers = boxplot(control[3:40], plot=FALSE,range=std)$out
Control=control
for (i in 3:40) {
Control= control[!control[,i] %in% boxplot(control[,i], plot=FALSE,range=std)$out,]
}
message("Proportion (%) of outliers: ", round((length(data[,1])-length(Sick[,1])-length(Control[,1])) /length(data[,1])*100,2))
#how to choose the ones to remove?
# why removing the outliers?
std=2
Sick=sick
for (i in 3:40) {
Sick= Sick[!Sick[,i] %in% boxplot(sick[,i], plot=FALSE,range=std)$out,]
}
outliers = boxplot(control[3:40], plot=FALSE,range=std)$out
Control=control
for (i in 3:40) {
Control= Control[!Control[,i] %in% boxplot(control[,i], plot=FALSE,range=std)$out,]
}
message("Proportion (%) of outliers: ", round((length(data[,1])-length(Sick[,1])-length(Control[,1])) /length(data[,1])*100,2))
#how to choose the ones to remove?
# why removing the outliers?
std=3
Sick=sick
for (i in 3:40) {
Sick= Sick[!Sick[,i] %in% boxplot(sick[,i], plot=FALSE,range=std)$out,]
}
outliers = boxplot(control[3:40], plot=FALSE,range=std)$out
Control=control
for (i in 3:40) {
Control= Control[!Control[,i] %in% boxplot(control[,i], plot=FALSE,range=std)$out,]
}
message("Proportion (%) of outliers: ", round((length(data[,1])-length(Sick[,1])-length(Control[,1])) /length(data[,1])*100,2))
#how to choose the ones to remove?
# why removing the outliers?
std=4
Sick=sick
for (i in 3:40) {
Sick= Sick[!Sick[,i] %in% boxplot(sick[,i], plot=FALSE,range=std)$out,]
}
outliers = boxplot(control[3:40], plot=FALSE,range=std)$out
Control=control
for (i in 3:40) {
Control= Control[!Control[,i] %in% boxplot(control[,i], plot=FALSE,range=std)$out,]
}
message("Proportion (%) of outliers: ", round((length(data[,1])-length(Sick[,1])-length(Control[,1])) /length(data[,1])*100,2))
#how to choose the ones to remove?
# why removing the outliers?
std=5
Sick=sick
for (i in 3:40) {
Sick= Sick[!Sick[,i] %in% boxplot(sick[,i], plot=FALSE,range=std)$out,]
}
outliers = boxplot(control[3:40], plot=FALSE,range=std)$out
Control=control
for (i in 3:40) {
Control= Control[!Control[,i] %in% boxplot(control[,i], plot=FALSE,range=std)$out,]
}
message("Proportion (%) of outliers: ", round((length(data[,1])-length(Sick[,1])-length(Control[,1])) /length(data[,1])*100,2))
length(data[,1])-length(Sick[,1])-length(Control[,1])
wilcox_pvalues=sapply(3:21, function(i){
wilcox.test(Sick[,i], Control[,i], )$p.value
})
wilcox_pvalues=as.data.frame(t(wilcox_pvalues))
colnames(wilcox_pvalues)=colnames(data[3:21])
wilcox_pvalues = t(wilcox_pvalues[ which(wilcox_pvalues[1,]>0.05)])
pander(wilcox_pvalues)
wilcox_pvalues=sapply(3:21, function(i){
wilcox.test(Sick[,i], Control[,i], )$p.value
})
wilcox_pvalues=as.data.frame(t(wilcox_pvalues))
colnames(wilcox_pvalues)=colnames(data[3:21])
wilcox_pvalues = t(wilcox_pvalues[ which(wilcox_pvalues[1,]>0.05)])
pander(wilcox_pvalues)
wilcox_pvalues=sapply(3:21, function(i){
wilcox.test(Sick[,i], Control[,i], )$p.value
})
wilcox_pvalues=as.data.frame(t(wilcox_pvalues))
colnames(wilcox_pvalues)=colnames(data[3:21])
wilcox_pvalues = t(wilcox_pvalues[ which(wilcox_pvalues[1,]<0.05)])
pander(wilcox_pvalues)
df$Groupe= as.factor(df$Groupe)
ncp=4
PCA.res = prcomp(df[-c(1,2)],center = T, scale = T,rank. = ncp)
# correlation plot
fviz_pca_var(PCA.res)
Classes=df$Groupe
#Score plot avec la librairie factoextra
fviz_pca_biplot(PCA.res,habillage=Classes)
fviz_screeplot(PCA.res, choice="eigenvalue")
PCA.res = prcomp(df[-c(1,2)],center = T, scale = T,rank. = ncp)
Classes=df$Groupe
fviz_pca_biplot(PCA.res,habillage=Classes)
warnings()
df=data
df= rbind(Sick,Control)
df
#how to choose the ones to remove?
# why removing the outliers?
std=5
Sick=sick
for (i in 3:40) {
Sick= Sick[!Sick[,i] %in% boxplot(sick[,i], plot=FALSE,range=std)$out,]
}
outliers = boxplot(control[3:40], plot=FALSE,range=std)$out
Control=control
for (i in 3:40) {
Control= Control[!Control[,i] %in% boxplot(control[,i], plot=FALSE,range=std)$out,]
}
df= rbind(Sick,Control)
message("Proportion (%) of outliers: ", round((length(data[,1])-length(Sick[,1])-length(Control[,1])) /length(data[,1])*100,2))
df= rbind(Sick,Control)
df$Groupe= as.factor(df$Groupe)
ncp=4
PCA.res = prcomp(df[3:21],center = T, scale = T,rank. = ncp)
fviz_pca_var(PCA.res)
Classes=df$Groupe
fviz_pca_biplot(PCA.res,habillage=Classes)
fviz_screeplot(PCA.res, choice="eigenvalue")
wilcox_pvalues=sapply(3:21, function(i){
wilcox.test(Sick[,i], Control[,i], )$p.value
})
wilcox_pvalues=as.data.frame(t(wilcox_pvalues))
colnames(wilcox_pvalues)=colnames(data[3:21])
wilcox_pvalues = t(wilcox_pvalues[ which(wilcox_pvalues[1,]<0.05)])
pander(wilcox_pvalues)
kable(round(PCA.res$x,2))
pander(round(PCA.res$rotation,2))
pander(round(PCA.res$rotation,2))
fviz_pca_var(PCA.res)
fviz_pca_biplot(PCA.res,habillage=Classes)
setwd("C:/Users/p/OneDrive - UCL/Traitement des données omics/Devoirs/projet données qPCR")
data=read.table("data_qPCR.csv",header=T,sep=";",dec=".")
sick=data[ which(data$Groupe=='malade'), ]
control=data[ which(data$Groupe=='temoin'), ]
smean=apply(sick[(3:21)],2,mean)
cmean=apply(control[(3:21)],2,mean)
barplot(height=t(cbind(smean,cmean)),beside=T,space=c(0,2),col=c("black","red"), border=F,main="Mean comparison")
legend("topleft",legend=c("sick","control"),fill=c("black","red"),cex=0.8)
smedian=apply(sick[(3:21)],2,median)
cmedian=apply(control[(3:21)],2,median)
barplot(height=t(cbind(smedian,cmedian)),beside=T,space=c(0,2),col=c("black","red"), border=F,main="Median comparison")
legend("topright",legend=c("sick","control"),fill=c("black","red"),cex=0.8)
corrplot(cor(sick[3:21]), tl.pos = "n")
title("variance-covariance Matrix, sick patients",line=3)
corrplot(cor(control[3:21]), tl.pos = "n")
title("variance-covariance Matrix, healthy patients",line=3)
#how to choose the ones to remove?
# why removing the outliers?
std=1.5
Sick=sick
for (i in 3:40) {
Sick= Sick[!Sick[,i] %in% boxplot(sick[,i], plot=FALSE,range=std)$out,]
}
outliers = boxplot(control[3:40], plot=FALSE,range=std)$out
Control=control
for (i in 3:40) {
Control= Control[!Control[,i] %in% boxplot(control[,i], plot=FALSE,range=std)$out,]
}
message("Proportion (%) of outliers: ", round((length(data[,1])-length(Sick[,1])-length(Control[,1])) /length(data[,1])*100,2))
length(data[,1])-length(Sick[,1])-length(Control[,1])
pander(round(PCA.res$rotation,2))
fviz_screeplot(PCA.res, choice="eigenvalue")
PCA.res = prcomp(df[3:21],center = T, scale = T,rank. = ncp)
PCA.res
fviz_pca_biplot(PCA.res,habillage=Classes, axes = c(1, 2,3,4))
fviz_pca_biplot(PCA.res,habillage=Classes,axes = c(3, 4))
kable(summary(PCA.res))
kable(summary(irismat,digit=4))
kable(summary(irismat,digit=4))
knit_with_parameters('C:/Users/p/OneDrive - UCL/Traitement des données omics/Devoirs/demo_pca_clustering.Rmd')
